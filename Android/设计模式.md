## 设计模式

#### 设计模式

##### 单例模式

> 确保单例类只有一个实例，并且这个单例类提供一个函数接口让其他类获取到这个唯一的实例。
> 如果某个类，创建时需要消耗很多资源，即new出这个类的代价很大；或者是这个类占用很多内存，如果创建太多这个类实例会导致内存占用太多。

###### 示例

```java
public class Singleton {
  private static Singleton instance;

  private Singleton() {
  }

  public static Singleton getInstance() {
    if (instance == null) {
      synchronized (Singleton.class) {
        instance = new Singleton();
      }
    }
    return instance;
  }
}
```

##### 建造者模式

> 将一个复杂对象的构造与它的表示分离，使得同样的构造过程可以创建不同的表示。
> 主要是在创建某个对象时，需要设定很多的参数（通过setter方法），但是这些参数必须按照某个顺序设定，或者是设置步骤不同会得到不同结果。

###### 示例

```java
Dialog Builder
```

##### 原型模式

> 当要创建的对象类型由原型实例确定时使用它，该实例被克隆以生成新对象。
>
> 场景:
>
> 当需要一个与现有对象类似的对象时，或者与克隆相比，创建的成本会很高。

##### 简单工厂模式（Simple Factory）

> 简单工厂只是为客户端生成一个实例，而不会向客户端公开任何实例化逻辑
>
> 场景:
>
> 当创建一个对象不仅仅是一些分配而且涉及一些逻辑时，将它放在专用工厂中而不是在任何地方重复相同的代码是有意义的

###### 示例

```kotlin
// Door.kt
interface Door {
    fun getWidth(): Float

    fun getHeight(): Float
}

// WoodenDoor.kt
class WoodenDoor(private var width: Float, private var height: Float) : Door {

    override fun getWidth(): Float {
        return width
    }

    override fun getHeight(): Float {
        return height
    }
}

// DoorFactory
object DoorFactory {
    fun makeDoor(width: Float, height: Float): Door {
        return WoodenDoor(width, height)
    }
}
```

##### 工厂方法模式(Factory Method)

> 在接口中指定并由子类实现，或者在基类中实现并可选地由派生类覆盖 - 而不是通过调用构造函数
>
> 场景：
>
> 在类中有一些通用处理但在运行时动态决定所需的子类时很有用。换句话说，当客户端不知道它可能需要什么样的子类时。

###### 示例

```kotlin
// 实现
interface Interviewer {
    fun askQuestions();
}

class Developer : Interviewer {
    override fun askQuestions() {
        println("Asking about design patterns!")
    }
}

class CommunityExecutive : Interviewer {
    override fun askQuestions() {
        println("Asking about community building")
    }
}

// 创造
abstract class HiringManager {
    protected abstract fun makeInterviewer(): Interviewer

    fun takeInterview() {
        val interviewer = makeInterviewer()
        interviewer.askQuestions()
    }
}

class DevelopmentManager : HiringManager() {
    override fun makeInterviewer(): Interviewer {
        return Developer();
    }
}

class MarketingManager : HiringManager() {
    override fun makeInterviewer(): Interviewer {
        return CommunityExecutive();
    }
}

// 应用
fun main(args: Array<String>) {
    val developmentManager = DevelopmentManager()
    developmentManager.takeInterview()

    val marketingManager = MarketingManager()
    marketingManager.takeInterview()
}


```

##### 抽象工厂模式（Abstract Factory）

> 将个人但相关/依赖工厂分组在一起而不指定其具体类别的工厂
>
> 场景：
>
> 当存在相互关联的依赖关系时，涉及非简单的创建逻辑



##### 适配器模式（Adapter）

> 适配器模式允许您在适配器中包装其他不兼容的对象，以使其与另一个类兼容

###### 示例

```kotlin
interface Lion {
    fun roar()
}

class AfricanLion : Lion {
    override fun roar() {}
}

class AsianLion : Lion {
    override fun roar() {}
}


class Hunter {
    fun hunt(lion: Lion) {
        lion.roar()
    }
}


class WildDog {
    fun bark() {
        println("犬吠")
    }
}

// 适配器
class WildAdapter(var dog: WildDog) : Lion {

    override fun roar() {
        this.dog.bark()
    }
}

fun main() {
    val wildDog = WildDog()
    val wildAdapter = WildAdapter(wildDog)

    val hunter = Hunter()
    hunter.hunt(wildAdapter)
}
```

##### 桥梁模式

> 桥模式是关于优先于继承的组合。实现细节从层次结构推送到具有单独层次结构的另一个对象。

![img](https://github.com/guanguans/design-patterns-for-humans-cn/raw/master/Docs/images/bridge.png)

##### 组合模式

> 复合模式允许客户以统一的方式处理单个对象

###### 示例

```kotlin
interface Employee {
    fun getName(): String
    fun setSalary(salary: Float)
    fun getSalary(): Float
    fun getRoles(): Array<String>
}


class Developer() : Employee {
    private var salary: Float = 0f
    private var name: String? = null
    private var roles: Array<String> = arrayOf()

    constructor(name: String, salary: Float) : this() {
        this.name = name
        this.salary = salary
    }


    override fun getName(): String = this.name ?: ""

    override fun setSalary(salary: Float) {
        this.salary = salary
    }


    override fun getSalary(): Float {
        return salary
    }

    override fun getRoles(): Array<String> {
        return roles
    }
}

class Designer() : Employee {
    private var salary: Float = 0f
    private var name: String? = null
    private var roles: Array<String> = arrayOf()

    constructor(name: String, salary: Float) : this() {
        this.name = name
        this.salary = salary
    }


    override fun getName(): String = this.name ?: ""

    override fun setSalary(salary: Float) {
        this.salary = salary
    }


    override fun getSalary(): Float {
        return salary
    }

    override fun getRoles(): Array<String> {
        return roles
    }
}

class Organization {
    private var employees: MutableList<Employee> = mutableListOf()

    fun addEmployee(employee: Employee) {
        employees.add(employee)
    }

    fun getNetSalaries(): Float {
        var netSalary = 0f
        employees.forEach { e ->
            netSalary += e.getSalary()
        }
        return netSalary
    }
}

fun main() {
    val jone = Developer("Jone", 12000f)
    val jake = Designer("jake", 15000f)

    val organization = Organization()
    organization.addEmployee(jone)
    organization.addEmployee(jake)

    println("Net salaries: " + organization.getNetSalaries())
}
```

##### 装饰模式（Decorator）

> 动态给对象添加一些额外的职责

###### 示例

```kotlin

abstract class Person {
    abstract fun dressed()
}

class Boy : Person() {
    override fun dressed() {
        println("穿了内衣内裤")
    }
}


abstract class PersonCloth(private val person: Person) : Person() {

    override fun dressed() {
        person.dressed()
    }
}

class ExpensiveCloth(person: Person) : PersonCloth(person) {
    private fun dressShirt() {
        println("穿短袖")
    }

    private fun dressLeather() {
        println("穿皮衣")
    }

    override fun dressed() {
        super.dressed()
        dressShirt()
        dressLeather()
    }
}

class CheapCloth(person: Person) : PersonCloth(person) {
    private fun dressShort() {
        println("穿短裤")
    }

    override fun dressed() {
        super.dressed()
        dressShort()
    }
}

fun main() {
    val boy: Person = Boy()
    val cheapCloth = CheapCloth(boy)
    cheapCloth.dressed()

    val expensiveCloth = ExpensiveCloth(boy)
    expensiveCloth.dressed()
}
```



##### 门面模式（Facade）

> Facade 模式为复杂的子系统提供了简化的界面。

###### 示例

```kotlin
class Computer {
    fun getElectricShock() {
        println("Ouch!")
    }

    fun makeSound() {
        println("Beep beep!")
    }

    fun showLoadingScreen() {
        println("Loading..")
    }

    fun bam() {
        println("Ready to be used!")
    }

    fun closeEverything() {
        println("Bup bup bup buzzzz!")
    }

    fun sooth() {
        println("Zzzzz")
    }

    fun pullCurrent() {
        println("Haaah!")
    }
}

class ComputerFacede(var computer: Computer) {
    fun turnOn() {
        computer.getElectricShock()
        computer.makeSound()
        computer.showLoadingScreen()
        computer.bam()
    }

    fun turnOff() {
        computer.closeEverything()
        computer.pullCurrent()
        computer.sooth()
    }
}


fun main() {
    val computerFacede = ComputerFacede(Computer())
    computerFacede.turnOn()
    computerFacede.turnOff()
}
```

##### 享元模式（Flyweight）

> 它用于通过尽可能多地与类似对象共享来最小化内存使用或计算开销
>
> 单纯享元模式：在单纯享元模式中，所有的具体享元类都是可以共享的，不存在非共享具体享元类。
> 复合享元模式：将一些单纯享元对象使用组合模式加以组合，还可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享

###### 示例

```kotlin
class KarakTea

class TeaMaker {
    private var availableTea: MutableMap<String, KarakTea> = mutableMapOf()

    fun make(pref: String): KarakTea {
        if (availableTea.get(pref) == null) {
            availableTea[pref] = KarakTea()
        }
        return availableTea[pref]!!
    }
}
```

##### 代理模式（Proxy）

##### 责任链模式（Chain Of Responsibilities）

##### 命令行模式（Command）

##### 迭代器模式（Iterator）

##### 中介者模式（Mediator）

##### 备忘录模式（Memento）

##### 观察者模式（Observer）

##### 访问者模式（Visitor）

##### 策略模式（Strategy）

##### 状态模式（State）

##### 模板方法模式（Template Method）





---

#### 六大原则

##### 单一职责原则 (Single Responsibility Principle - SRP)

> 将一组相关性很高的函数、数据封装到一个类中，换句话说，一个类应该有职责单一

##### 开闭原则 (Open Close Principle - OCP)

> 软件中的对象对于扩展是开放的，对于修改是封闭的

##### 里氏替换原则 (Liskov Substitution Principle - LSP)

>  所有引用基类的地方必须能透明地使用其子类对象。本质上就是说要好好利用继承和多态，从而以父类的形式来声明变量（或形参），为变量（或形参）赋值任何继承于这个父类的子类。
>
>  `开闭原则`通过`里氏替换原则`实现对扩展开放，对修改封闭的效果

##### 依赖倒置原则 (Dependence Inversion Principle - DIP)

> 关键点：
> 1. 高层模块`（调用端）`不应该依赖低层模块`(具体实现类)`，两者都依赖其抽象
> 2. 抽象`（接口或抽象类）`不应该依赖细节`（实现类）`
> 3. 细节应该依赖抽象

示例：

##### 接口隔离原则 (InterfaceSegregation Principles - ISP)

> 客户端不应该依赖他不需要的接口（类间的依赖关系应该建立在最小的接口上）
>
> 将非常庞大臃肿的接口拆分成更小的更具体的接口，客户只需要知道他们感兴趣的方法

##### 迪米特原则 (Law of Demeter - LOD)

> 一个对象应该对其他对象有最小的了解，类似租户，中介与房屋的关系，租户只需要知道是否有合适房屋，而匹配工作都由中介完成，无论他如何去搜索

#### 相关文章

[Github guanguans/design-patterns-for-humans-cn](https://github.com/guanguans/design-patterns-for-humans-cn)

[Github simple-android-framework-exchange/android_design_patterns_analysis](https://github.com/simple-android-framework-exchange/android_design_patterns_analysis)

[图说设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/index.html)

[掘金 谈谈 23 种设计模式在 Android 项目中的应用]([https://juejin.im/entry/5b4b35fe6fb9a04fb401546d#%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99](https://juejin.im/entry/5b4b35fe6fb9a04fb401546d#六大原则))